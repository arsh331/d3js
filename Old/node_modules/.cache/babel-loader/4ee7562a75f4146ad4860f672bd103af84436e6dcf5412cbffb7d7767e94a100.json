{"ast":null,"code":"var _jsxFileName = \"/gsoc/git/d3js/src/Data.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from \"react\";\nimport SimilarArtistsGraph from \"./SimilarArtistsGraph\";\nimport tinycolor from \"tinycolor2\";\nimport SearchBox from \"./artist-search/SearchBox\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst colorGenerator = () => {\n  var color = tinycolor(\"hsv(\" + Math.random() * 360 + \", 90%, 90%)\");\n  return color;\n};\nconst Data = () => {\n  _s();\n  var _similarArtistsList$s, _similarArtistsList;\n  const ARTIST_MBID = \"8f6bd1e4-fbe1-4f50-aa9b-94c450ec0f11\";\n  const SIMILAR_ARTISTS_LIMIT_VALUE = 18;\n  const BASE_URL = \"https://labs.api.listenbrainz.org/similar-artists/json?algorithm=session_based_days_7500_session_300_contribution_5_threshold_10_limit_100_filter_True_skip_30&artist_mbid=\";\n  // Serves as the maximum distance between nodes\n  const LINK_DIST_MULTIPLIER = 250;\n  // Serves as the minimum distance between nodes\n  const MIN_LINK_DIST = 0;\n  // Size of the main node\n  const MAIN_NODE_SIZE = 150;\n  // Size of the similar nodes\n  const SIMILAR_NODE_SIZE = 85;\n  // Apha value of the background color of the graph\n  const BACKGROUND_ALPHA = 0.2;\n  const COLOR_MIX_WEIGHT = 0.3;\n  // Score in case it is undefined (as in case of main artist)\n  const NULL_SCORE = Infinity;\n  var color1 = colorGenerator();\n  var color2 = color1.clone().tetrad()[1];\n  const [similarArtistsList, setSimilarArtistsList] = useState();\n  const [mainArtist, setMainArtist] = useState();\n  const [similarArtistsLimit, setSimilarArtistsLimit] = useState(SIMILAR_ARTISTS_LIMIT_VALUE);\n  const [colors, setColors] = useState([color1, color2]);\n  const [artistMBID, setArtistMBID] = useState(ARTIST_MBID);\n  var scoreList = [];\n  const fetchData = async ARTIST_MBID => {\n    try {\n      const response = await fetch(BASE_URL + ARTIST_MBID);\n      const data = await response.json();\n      processData(data);\n    } catch (error) {\n      //Error message goes here.\n      alert(\"Something went wrong while loading information, please try again\");\n    }\n  };\n  const processData = dataResponse => {\n    // Type guard for dataset response\n    const isDatasetResponse = response => {\n      return response.type === \"dataset\";\n    };\n    // Get the datasets out of the API response\n    const artistsData = dataResponse.filter(isDatasetResponse);\n    if (artistsData.length) {\n      var _similarArtistsRespon;\n      // Get the main artist from the first dataset\n      setMainArtist(artistsData[0].data[0]);\n      // Get the similar artists from the second dataset\n      const similarArtistsResponse = artistsData[1];\n      if (similarArtistsResponse !== null && similarArtistsResponse !== void 0 && (_similarArtistsRespon = similarArtistsResponse.data) !== null && _similarArtistsRespon !== void 0 && _similarArtistsRespon.length) {\n        setSimilarArtistsList(similarArtistsResponse.data.slice(0, similarArtistsLimit));\n      }\n      // In case no similar artists are found\n      else {\n        setSimilarArtistsList([]);\n      }\n    }\n    setColors([tinycolor.mix(color1, color2, COLOR_MIX_WEIGHT), color2]);\n  };\n\n  // Update the graph when either artistMBID or similarArtistsLimit changes\n  useEffect(() => {\n    fetchData(artistMBID);\n  }, [artistMBID, similarArtistsLimit]);\n\n  // Calculating minScore for normalization which is always the last element of the array (because it's sorted)\n  var minScore = (_similarArtistsList$s = similarArtistsList === null || similarArtistsList === void 0 ? void 0 : (_similarArtistsList = similarArtistsList[similarArtistsLimit - 1]) === null || _similarArtistsList === void 0 ? void 0 : _similarArtistsList.score) !== null && _similarArtistsList$s !== void 0 ? _similarArtistsList$s : 0;\n  minScore = Math.sqrt(minScore);\n\n  // Transforming the data into the format required by the graph\n  let transformedArtists = {\n    nodes: [],\n    links: []\n  };\n  // Checking if mainArtist is defined\n  if (mainArtist) {\n    transformedArtists = {\n      nodes: [mainArtist, ...similarArtistsList].map((similarArtist, index) => {\n        var _similarArtist$score2;\n        let computedScore;\n        let computedColor;\n        if (similarArtist !== mainArtist) {\n          var _similarArtist$score;\n          computedScore = minScore / Math.sqrt((_similarArtist$score = similarArtist === null || similarArtist === void 0 ? void 0 : similarArtist.score) !== null && _similarArtist$score !== void 0 ? _similarArtist$score : NULL_SCORE);\n          computedColor = tinycolor.mix(colors[0], colors[1], index / similarArtistsLimit * computedScore * 100);\n          scoreList.push(computedScore);\n        } else {\n          computedColor = colors[0];\n        }\n        return {\n          id: similarArtist.name,\n          artist_mbid: similarArtist.artist_mbid,\n          size: similarArtist.artist_mbid === (mainArtist === null || mainArtist === void 0 ? void 0 : mainArtist.artist_mbid) ? MAIN_NODE_SIZE : SIMILAR_NODE_SIZE,\n          color: computedColor.toRgbString(),\n          score: (_similarArtist$score2 = similarArtist.score) !== null && _similarArtist$score2 !== void 0 ? _similarArtist$score2 : NULL_SCORE\n        };\n      }),\n      links: similarArtistsList.map((similarArtist, index) => {\n        var _mainArtist$name;\n        return {\n          source: (_mainArtist$name = mainArtist === null || mainArtist === void 0 ? void 0 : mainArtist.name) !== null && _mainArtist$name !== void 0 ? _mainArtist$name : \"\",\n          target: similarArtist.name,\n          distance: scoreList[index] * LINK_DIST_MULTIPLIER + MIN_LINK_DIST\n        };\n      })\n    };\n  }\n  const backgroundColor1 = colors[0].clone().setAlpha(BACKGROUND_ALPHA).toRgbString();\n  const backgroundColor2 = colors[1].clone().setAlpha(BACKGROUND_ALPHA).toRgbString();\n  const backgroundGradient = `linear-gradient(` + backgroundColor1 + `,` + backgroundColor2 + `)`;\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(SearchBox, {\n      onArtistChange: setArtistMBID,\n      currentArtistMbid: artistMBID,\n      onsimilarArtistsLimitChange: setSimilarArtistsLimit,\n      currentsimilarArtistsLimit: similarArtistsLimit\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 169,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(SimilarArtistsGraph, {\n      onArtistChange: setArtistMBID,\n      data: transformedArtists,\n      background: backgroundGradient\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 171,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 166,\n    columnNumber: 9\n  }, this);\n};\n_s(Data, \"TFq3eIcbmjxtQnLFeUTOn7/YaX4=\");\n_c = Data;\nexport default Data;\nvar _c;\n$RefreshReg$(_c, \"Data\");","map":{"version":3,"names":["React","useState","useEffect","SimilarArtistsGraph","tinycolor","SearchBox","jsxDEV","_jsxDEV","colorGenerator","color","Math","random","Data","_s","_similarArtistsList$s","_similarArtistsList","ARTIST_MBID","SIMILAR_ARTISTS_LIMIT_VALUE","BASE_URL","LINK_DIST_MULTIPLIER","MIN_LINK_DIST","MAIN_NODE_SIZE","SIMILAR_NODE_SIZE","BACKGROUND_ALPHA","COLOR_MIX_WEIGHT","NULL_SCORE","Infinity","color1","color2","clone","tetrad","similarArtistsList","setSimilarArtistsList","mainArtist","setMainArtist","similarArtistsLimit","setSimilarArtistsLimit","colors","setColors","artistMBID","setArtistMBID","scoreList","fetchData","response","fetch","data","json","processData","error","alert","dataResponse","isDatasetResponse","type","artistsData","filter","length","_similarArtistsRespon","similarArtistsResponse","slice","mix","minScore","score","sqrt","transformedArtists","nodes","links","map","similarArtist","index","_similarArtist$score2","computedScore","computedColor","_similarArtist$score","push","id","name","artist_mbid","size","toRgbString","_mainArtist$name","source","target","distance","backgroundColor1","setAlpha","backgroundColor2","backgroundGradient","children","onArtistChange","currentArtistMbid","onsimilarArtistsLimitChange","currentsimilarArtistsLimit","fileName","_jsxFileName","lineNumber","columnNumber","background","_c","$RefreshReg$"],"sources":["/gsoc/git/d3js/src/Data.tsx"],"sourcesContent":["import React, {useState, useEffect} from \"react\";\nimport SimilarArtistsGraph from \"./SimilarArtistsGraph\";\nimport tinycolor from \"tinycolor2\";\nimport SearchBox from \"./artist-search/SearchBox\";\n\ntype ArtistType = {\n    artist_mbid: string;\n    name: string;\n    comment?: string;\n    type?: string;\n    gender?: string;\n    score?: number;\n    reference_mbid?: string;\n}\n    \ntype MarkupResponseType = {\n    data: string;\n    type: \"markup\";\n}\n\ntype DatasetResponseType = {\n    columns: Array<string>;\n    data: Array<ArtistType>;\n    type: \"dataset\";\n}\n\ntype ApiResponseType = Array<MarkupResponseType | DatasetResponseType>;\n\ntype NodeType = {\n    id: string;\n    artist_mbid: string;\n    size: number;\n    color: string;\n    score: number;\n}\n\ntype LinkType = {\n    source: string;\n    target: string;\n    distance: number;\n}\n\ntype GraphDataType = {\n    nodes: Array<NodeType>;\n    links: Array<LinkType>;\n}\n\nconst colorGenerator = ():  tinycolor.Instance=> {\n    var color = tinycolor(\"hsv(\" + Math.random() * 360 + \", 90%, 90%)\");\n    return color;\n}\n\nconst Data = () => {\n    const ARTIST_MBID = \"8f6bd1e4-fbe1-4f50-aa9b-94c450ec0f11\";\n    const SIMILAR_ARTISTS_LIMIT_VALUE = 18;\n    const BASE_URL = \"https://labs.api.listenbrainz.org/similar-artists/json?algorithm=session_based_days_7500_session_300_contribution_5_threshold_10_limit_100_filter_True_skip_30&artist_mbid=\";\n    // Serves as the maximum distance between nodes\n    const LINK_DIST_MULTIPLIER = 250;\n    // Serves as the minimum distance between nodes\n    const MIN_LINK_DIST = 0;\n    // Size of the main node\n    const MAIN_NODE_SIZE = 150;\n    // Size of the similar nodes\n    const SIMILAR_NODE_SIZE = 85;\n    // Apha value of the background color of the graph\n    const BACKGROUND_ALPHA = 0.2;\n    const COLOR_MIX_WEIGHT = 0.3;\n    // Score in case it is undefined (as in case of main artist)\n    const NULL_SCORE = Infinity;\n\n    var color1 = colorGenerator();\n    var color2 = color1.clone().tetrad()[1];\n    const [similarArtistsList, setSimilarArtistsList] = useState<Array<ArtistType>>();\n    const [mainArtist, setMainArtist] = useState<ArtistType>();\n    const [similarArtistsLimit, setSimilarArtistsLimit] = useState(SIMILAR_ARTISTS_LIMIT_VALUE);\n    const [colors, setColors] = useState([color1, color2]);\n    const [artistMBID, setArtistMBID] = useState(ARTIST_MBID);\n\n    var scoreList: Array<number> = [];\n    \n    const fetchData = async (ARTIST_MBID: string): Promise<void> => {\n        try {\n          const response = await fetch(BASE_URL + ARTIST_MBID);\n          const data = await response.json();\n          processData(data);\n        }\n        catch (error){\n          //Error message goes here.\n          alert(\"Something went wrong while loading information, please try again\");\n        }\n    }\n    \n    const processData = (dataResponse: ApiResponseType): void => {\n        // Type guard for dataset response\n        const isDatasetResponse = (response: MarkupResponseType | DatasetResponseType): \n        response is DatasetResponseType => {\n            return response.type === \"dataset\";\n        }\n        // Get the datasets out of the API response\n        const artistsData = dataResponse.filter(isDatasetResponse);\n        if(artistsData.length){\n            // Get the main artist from the first dataset\n            setMainArtist(artistsData[0].data[0]);\n            // Get the similar artists from the second dataset\n            const similarArtistsResponse = artistsData[1];\n            if(similarArtistsResponse?.data?.length){\n                setSimilarArtistsList(similarArtistsResponse.data.slice(0, similarArtistsLimit));\n            }\n            // In case no similar artists are found\n            else{\n                setSimilarArtistsList([]);\n            }\n        }\n        setColors([tinycolor.mix(color1, color2, COLOR_MIX_WEIGHT), color2]);\n    }\n    \n    // Update the graph when either artistMBID or similarArtistsLimit changes\n    useEffect(() => {\n        fetchData(artistMBID);\n    }, [artistMBID, similarArtistsLimit]);\n\n    // Calculating minScore for normalization which is always the last element of the array (because it's sorted)\n    var minScore = similarArtistsList?.[similarArtistsLimit - 1]?.score ?? 0;\n    minScore = Math.sqrt(minScore);\n\n    // Transforming the data into the format required by the graph\n    let transformedArtists: GraphDataType = {\n        nodes: [],\n        links: []\n    };\n    // Checking if mainArtist is defined\n    if(mainArtist) {\n        transformedArtists = {\n            nodes: [mainArtist, ...similarArtistsList!].map((similarArtist: ArtistType, index: number): NodeType => {\n                let computedScore;\n                let computedColor;\n                if(similarArtist !== mainArtist) {\n                    computedScore = minScore / Math.sqrt(similarArtist?.score ?? NULL_SCORE);\n                    computedColor = tinycolor.mix(colors[0], colors[1], (index / similarArtistsLimit * computedScore) * 100);\n                    scoreList.push(computedScore);\n                }\n                else {\n                    computedColor = colors[0];\n                }\n                return {\n                    id: similarArtist.name,\n                    artist_mbid: similarArtist.artist_mbid,\n                    size: similarArtist.artist_mbid === mainArtist?.artist_mbid ? MAIN_NODE_SIZE : SIMILAR_NODE_SIZE,\n                    color: computedColor.toRgbString(),\n                    score: similarArtist.score ?? NULL_SCORE\n                };\n            }),\n            links: similarArtistsList!.map((similarArtist: ArtistType, index: number): LinkType => {\n                return {\n                    source: mainArtist?.name ?? \"\",\n                    target: similarArtist.name,\n                    distance: scoreList[index] * LINK_DIST_MULTIPLIER + MIN_LINK_DIST,\n                };\n            }),\n        }\n    }\n    const backgroundColor1 = colors[0].clone().setAlpha(BACKGROUND_ALPHA).toRgbString();\n    const backgroundColor2 = colors[1].clone().setAlpha(BACKGROUND_ALPHA).toRgbString();\n    const backgroundGradient = `linear-gradient(` + backgroundColor1 + `,` + backgroundColor2 + `)`;\n    return (\n        <div>\n            {//<Input onArtistChange={setArtistMBID} onLimitChange={setSimilarArtistsLimit}/>\n            }\n            <SearchBox onArtistChange={setArtistMBID} currentArtistMbid={artistMBID} onsimilarArtistsLimitChange={setSimilarArtistsLimit} currentsimilarArtistsLimit={similarArtistsLimit}/>\n            {/*<SearchBx />*/}\n            <SimilarArtistsGraph onArtistChange={setArtistMBID} data={transformedArtists} background={backgroundGradient}/>\n        </div>\n    );\n}\n\nexport default Data;\nexport type { GraphDataType, NodeType, LinkType, ArtistType};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}