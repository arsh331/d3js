{"ast":null,"code":"var _jsxFileName = \"/gsoc/git/d3js/src/Data.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from \"react\";\nimport SimilarArtistsGraph from \"./SimilarArtistsGraph\";\nimport Input from \"./artist-search/SearchBox\";\nimport tinycolor from \"tinycolor2\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst colorGenerator = () => {\n  var color = tinycolor(\"hsv(\" + Math.random() * 360 + \", 100%, 70%)\");\n  return color;\n};\nconst Data = () => {\n  _s();\n  var _similarArtists$score, _similarArtists;\n  const ARTIST_MBID = \"8f6bd1e4-fbe1-4f50-aa9b-94c450ec0f11\";\n  const SIMILAR_ARTISTS_LIMIT_VALUE = 18;\n  const BASE_URL = \"https://labs.api.listenbrainz.org/similar-artists/json?algorithm=session_based_days_7500_session_300_contribution_5_threshold_10_limit_100_filter_True_skip_30&artist_mbid=\";\n  // Serves as the maximum distance between nodes\n  const LINK_DIST_MULTIPLIER = 150;\n  // Serves as the minimum distance between nodes\n  const MIN_LINK_DIST = 100;\n  // Size of the main node\n  const MAIN_NODE_SIZE = 150;\n  // Size of the similar nodes\n  const SIMILAR_NODE_SIZE = 85;\n  // Apha value of the background color of the graph\n  const BACKGROUND_ALPHA = 0.2;\n  const COLOR_MIX_WEIGHT = 0.3;\n  // Score in case it is undefined (as in case of main artist)\n  const NULL_SCORE = Infinity;\n  var color1 = colorGenerator();\n  var color2 = color1.clone().triad()[1];\n  console.log(color1.toHexString() + \" \" + color2.toHexString());\n  const [similarArtists, setSimilarArtists] = useState();\n  const [mainArtist, setMainArtist] = useState();\n  const [similarArtistsLimit, setSimilarArtistsLimit] = useState(SIMILAR_ARTISTS_LIMIT_VALUE);\n  const [colors, setColors] = useState([color1, color2]);\n  const [artistMBID, setArtistMBID] = useState(ARTIST_MBID);\n  var scoreList = [];\n  const fetchData = async ARTIST_MBID => {\n    try {\n      const response = await fetch(BASE_URL + ARTIST_MBID);\n      const data = await response.json();\n      processData(data);\n    } catch (error) {\n      //Error message goes here.\n      alert(\"Something went wrong while loading information, please try again\");\n    }\n  };\n  const processData = dataResponse => {\n    // Type guard for dataset response\n    const isDatasetResponse = response => {\n      return response.type === \"dataset\";\n    };\n    // Get the datasets out of the API response\n    const artistsData = dataResponse.filter(isDatasetResponse);\n    if (artistsData.length) {\n      var _similarArtistsRespon;\n      // Get the main artist from the first dataset\n      setMainArtist(artistsData[0].data[0]);\n      // Get the similar artists from the second dataset\n      const similarArtistsResponse = artistsData[1];\n      if (similarArtistsResponse !== null && similarArtistsResponse !== void 0 && (_similarArtistsRespon = similarArtistsResponse.data) !== null && _similarArtistsRespon !== void 0 && _similarArtistsRespon.length) {\n        setSimilarArtists(similarArtistsResponse.data.slice(0, similarArtistsLimit));\n      }\n    }\n    setColors([tinycolor.mix(color1, color2, COLOR_MIX_WEIGHT), color2]);\n  };\n\n  // Update the graph when either artistMBID or similarArtistsLimit changes\n  useEffect(() => {\n    fetchData(artistMBID);\n  }, [artistMBID, similarArtistsLimit]);\n\n  // Calculating minScore for normalization which is always the last element of the array (because it's sorted)\n  var minScore = (_similarArtists$score = similarArtists === null || similarArtists === void 0 ? void 0 : (_similarArtists = similarArtists[similarArtistsLimit - 1]) === null || _similarArtists === void 0 ? void 0 : _similarArtists.score) !== null && _similarArtists$score !== void 0 ? _similarArtists$score : 0;\n  minScore = Math.sqrt(minScore);\n\n  // Transforming the data into the format required by the graph\n  let transformedArtists = {\n    nodes: [],\n    links: []\n  };\n  // Checking if mainArtist and similarArtists are defined\n  if (mainArtist && similarArtists !== null && similarArtists !== void 0 && similarArtists.length) {\n    transformedArtists = {\n      nodes: [mainArtist, ...similarArtists].map((similarArtist, index) => {\n        var _similarArtist$score2;\n        let computedScore;\n        let computedColor;\n        if (similarArtist !== mainArtist) {\n          var _similarArtist$score;\n          computedScore = minScore / Math.sqrt((_similarArtist$score = similarArtist === null || similarArtist === void 0 ? void 0 : similarArtist.score) !== null && _similarArtist$score !== void 0 ? _similarArtist$score : NULL_SCORE);\n          computedColor = tinycolor.mix(colors[0], colors[1], index / similarArtistsLimit * computedScore * 100);\n          scoreList.push(computedScore);\n        } else {\n          computedColor = colors[0];\n        }\n        return {\n          id: similarArtist.name,\n          artist_mbid: similarArtist.artist_mbid,\n          size: similarArtist.artist_mbid === (mainArtist === null || mainArtist === void 0 ? void 0 : mainArtist.artist_mbid) ? MAIN_NODE_SIZE : SIMILAR_NODE_SIZE,\n          color: computedColor.toRgbString(),\n          score: (_similarArtist$score2 = similarArtist.score) !== null && _similarArtist$score2 !== void 0 ? _similarArtist$score2 : NULL_SCORE\n        };\n      }),\n      links: similarArtists.map((similarArtist, index) => {\n        var _mainArtist$name;\n        return {\n          source: (_mainArtist$name = mainArtist === null || mainArtist === void 0 ? void 0 : mainArtist.name) !== null && _mainArtist$name !== void 0 ? _mainArtist$name : \"\",\n          target: similarArtist.name,\n          distance: scoreList[index] * LINK_DIST_MULTIPLIER + MIN_LINK_DIST\n        };\n      })\n    };\n  }\n  const backgroundColor1 = colors[0].clone().setAlpha(BACKGROUND_ALPHA).toRgbString();\n  const backgroundColor2 = colors[1].clone().setAlpha(BACKGROUND_ALPHA).toRgbString();\n  const backgroundGradient = `linear-gradient(` + backgroundColor1 + `,` + backgroundColor2 + `)`;\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(Input, {\n      onArtistChange: setArtistMBID,\n      onLimitChange: setSimilarArtistsLimit\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 164,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(SimilarArtistsGraph, {\n      onArtistChange: setArtistMBID,\n      data: transformedArtists,\n      background: backgroundGradient\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 165,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 163,\n    columnNumber: 9\n  }, this);\n};\n_s(Data, \"kjHZrzy0HhKRp2FzFiThbZvVA4A=\");\n_c = Data;\nexport default Data;\nvar _c;\n$RefreshReg$(_c, \"Data\");","map":{"version":3,"names":["React","useState","useEffect","SimilarArtistsGraph","Input","tinycolor","jsxDEV","_jsxDEV","colorGenerator","color","Math","random","Data","_s","_similarArtists$score","_similarArtists","ARTIST_MBID","SIMILAR_ARTISTS_LIMIT_VALUE","BASE_URL","LINK_DIST_MULTIPLIER","MIN_LINK_DIST","MAIN_NODE_SIZE","SIMILAR_NODE_SIZE","BACKGROUND_ALPHA","COLOR_MIX_WEIGHT","NULL_SCORE","Infinity","color1","color2","clone","triad","console","log","toHexString","similarArtists","setSimilarArtists","mainArtist","setMainArtist","similarArtistsLimit","setSimilarArtistsLimit","colors","setColors","artistMBID","setArtistMBID","scoreList","fetchData","response","fetch","data","json","processData","error","alert","dataResponse","isDatasetResponse","type","artistsData","filter","length","_similarArtistsRespon","similarArtistsResponse","slice","mix","minScore","score","sqrt","transformedArtists","nodes","links","map","similarArtist","index","_similarArtist$score2","computedScore","computedColor","_similarArtist$score","push","id","name","artist_mbid","size","toRgbString","_mainArtist$name","source","target","distance","backgroundColor1","setAlpha","backgroundColor2","backgroundGradient","children","onArtistChange","onLimitChange","fileName","_jsxFileName","lineNumber","columnNumber","background","_c","$RefreshReg$"],"sources":["/gsoc/git/d3js/src/Data.tsx"],"sourcesContent":["import React, {useState, useEffect} from \"react\";\nimport SimilarArtistsGraph from \"./SimilarArtistsGraph\";\nimport Input from \"./artist-search/SearchBox\";\nimport tinycolor from \"tinycolor2\";\n\ntype ArtistType = {\n    artist_mbid: string;\n    name: string;\n    comment: string;\n    type: string;\n    gender: string;\n    score?: number;\n    reference_mbid?: string;\n}\n    \ntype MarkupResponseType = {\n    data: string;\n    type: \"markup\";\n}\n\ntype DatasetResponseType = {\n    columns: Array<string>;\n    data: Array<ArtistType>;\n    type: \"dataset\";\n}\n\ntype ApiResponseType = Array<MarkupResponseType | DatasetResponseType>;\n\ntype NodeType = {\n    id: string;\n    artist_mbid: string;\n    size: number;\n    color: string;\n    score: number;\n}\n\ntype LinkType = {\n    source: string;\n    target: string;\n    distance: number;\n}\n\ntype GraphDataType = {\n    nodes: Array<NodeType>;\n    links: Array<LinkType>;\n}\n\nconst colorGenerator = ():  tinycolor.Instance=> {\n    var color = tinycolor(\"hsv(\" + Math.random() * 360 + \", 100%, 70%)\");\n    return color;\n}\n\nconst Data = () => {\n    const ARTIST_MBID = \"8f6bd1e4-fbe1-4f50-aa9b-94c450ec0f11\";\n    const SIMILAR_ARTISTS_LIMIT_VALUE = 18;\n    const BASE_URL = \"https://labs.api.listenbrainz.org/similar-artists/json?algorithm=session_based_days_7500_session_300_contribution_5_threshold_10_limit_100_filter_True_skip_30&artist_mbid=\";\n    // Serves as the maximum distance between nodes\n    const LINK_DIST_MULTIPLIER = 150;\n    // Serves as the minimum distance between nodes\n    const MIN_LINK_DIST = 100;\n    // Size of the main node\n    const MAIN_NODE_SIZE = 150;\n    // Size of the similar nodes\n    const SIMILAR_NODE_SIZE = 85;\n    // Apha value of the background color of the graph\n    const BACKGROUND_ALPHA = 0.2;\n    const COLOR_MIX_WEIGHT = 0.3;\n    // Score in case it is undefined (as in case of main artist)\n    const NULL_SCORE = Infinity;\n\n    var color1 = colorGenerator();\n    var color2 = color1.clone().triad()[1];\n    console.log(color1.toHexString() + \" \" + color2.toHexString());\n    const [similarArtists, setSimilarArtists] = useState<Array<ArtistType>>();\n    const [mainArtist, setMainArtist] = useState<ArtistType>();\n    const [similarArtistsLimit, setSimilarArtistsLimit] = useState(SIMILAR_ARTISTS_LIMIT_VALUE);\n    const [colors, setColors] = useState([color1, color2]);\n    const [artistMBID, setArtistMBID] = useState(ARTIST_MBID);\n\n    var scoreList: Array<number> = [];\n    \n    const fetchData = async (ARTIST_MBID: string): Promise<void> => {\n        try {\n          const response = await fetch(BASE_URL + ARTIST_MBID);\n          const data = await response.json();\n          processData(data);\n        }\n        catch (error){\n          //Error message goes here.\n          alert(\"Something went wrong while loading information, please try again\");\n        }\n    }\n    \n    const processData = (dataResponse: ApiResponseType): void => {\n        // Type guard for dataset response\n        const isDatasetResponse = (response: MarkupResponseType | DatasetResponseType): \n        response is DatasetResponseType => {\n            return response.type === \"dataset\";\n        }\n        // Get the datasets out of the API response\n        const artistsData = dataResponse.filter(isDatasetResponse);\n        if(artistsData.length){\n            // Get the main artist from the first dataset\n            setMainArtist(artistsData[0].data[0]);\n            // Get the similar artists from the second dataset\n            const similarArtistsResponse = artistsData[1];\n            if(similarArtistsResponse?.data?.length){\n                setSimilarArtists(similarArtistsResponse.data.slice(0, similarArtistsLimit));\n            }\n        }\n        setColors([tinycolor.mix(color1, color2, COLOR_MIX_WEIGHT), color2]);\n    }\n    \n    // Update the graph when either artistMBID or similarArtistsLimit changes\n    useEffect(() => {\n        fetchData(artistMBID);\n    }, [artistMBID, similarArtistsLimit]);\n\n    // Calculating minScore for normalization which is always the last element of the array (because it's sorted)\n    var minScore = similarArtists?.[similarArtistsLimit - 1]?.score ?? 0;\n    minScore = Math.sqrt(minScore);\n\n    // Transforming the data into the format required by the graph\n    let transformedArtists: GraphDataType = {\n        nodes: [],\n        links: []\n    };\n    // Checking if mainArtist and similarArtists are defined\n    if(mainArtist && similarArtists?.length) { \n        transformedArtists = {\n            nodes: [mainArtist, ...similarArtists].map((similarArtist: ArtistType, index: number): NodeType => {\n                let computedScore;\n                let computedColor;\n                if(similarArtist !== mainArtist) {\n                    computedScore = minScore / Math.sqrt(similarArtist?.score ?? NULL_SCORE);\n                    computedColor = tinycolor.mix(colors[0], colors[1], (index / similarArtistsLimit * computedScore) * 100);\n                    scoreList.push(computedScore);\n                }\n                else {\n                    computedColor = colors[0];\n                }\n                return {\n                    id: similarArtist.name,\n                    artist_mbid: similarArtist.artist_mbid,\n                    size: similarArtist.artist_mbid === mainArtist?.artist_mbid ? MAIN_NODE_SIZE : SIMILAR_NODE_SIZE,\n                    color: computedColor.toRgbString(),\n                    score: similarArtist.score ?? NULL_SCORE\n                };\n            }),\n            links: similarArtists.map((similarArtist: ArtistType, index: number): LinkType => {\n                return {\n                    source: mainArtist?.name ?? \"\",\n                    target: similarArtist.name,\n                    distance: scoreList[index] * LINK_DIST_MULTIPLIER + MIN_LINK_DIST,\n                };\n            }),\n        }\n    }\n    const backgroundColor1 = colors[0].clone().setAlpha(BACKGROUND_ALPHA).toRgbString();\n    const backgroundColor2 = colors[1].clone().setAlpha(BACKGROUND_ALPHA).toRgbString();\n    const backgroundGradient = `linear-gradient(` + backgroundColor1 + `,` + backgroundColor2 + `)`;\n    return (\n        <div>\n            <Input onArtistChange={setArtistMBID} onLimitChange={setSimilarArtistsLimit}/>\n            <SimilarArtistsGraph onArtistChange={setArtistMBID} data={transformedArtists} background={backgroundGradient}/>\n        </div>\n    );\n}\n\nexport default Data;\nexport type { GraphDataType, NodeType, LinkType};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}